# CTA 實作計畫回顧報告

針對您的使用者行為埋點分析系統(POC) 實作計畫進行審查，以下是關於需求理解、計畫可行性及模糊內容的問題與建議。

## 🤔 關於需求理解的問題

### 1. **跨批次重複事件標記位置問題**
在規格中提到：「跨批次 eventId 重複 → 接受，但標記 `flags.duplicate_eventId=true`」，但計畫中提到在 `EventStore` 中建立跨批次重複事件查找。問題是：這個標記應該在何時何處進行？是在接收到新事件時立即檢查並標記，還是需要在事件存儲後再更新標記？

### 2. **metadata 欄位驗證的彈性問題**
規格中提到 `metadata` 依 `eventType` 定義必填欄位（如 `enter_screen` 需要 `view`，`click` 需要 `componentId`），但對於未知的 `eventType` 應如何處理其必填欄位？如果前端發送了新的 `eventType`（如 `scroll`）但沒有相應的必填欄位，這應該算是 `MISSING_METADATA` 或是 `unknown_eventType`？

## ⚠️ 關於計畫可行性的問題

### 3. **In-Memory 資料結構的併發安全問題**
計畫中提到使用 In-Memory 事件儲存，並採用全域自增 `seqId`。但未提及並發存取的安全性問題。當多個請求同時嘗試存儲事件時，如何確保 `seqId` 的唯一性和事件順序的正確性？是否需要考慮使用 `ConcurrentQueue` 或鎖定機制？

### 4. **事件查詢效能問題**
對於事件歷程查詢功能，計畫中提到依 `seqId` 排序，但若在記憶體中存儲大量事件（即使在 POC 階段），查詢特定公司事件或使用 Cursor 查詢時可能導致效能問題。是否有考慮到記憶體索引策略（如按 `companyId` 建立索引）？

## 🔍 關於模糊計畫內容的問題

### 5. **Cursor 服務的具體實作細節**
Cursor 格式定義為 `{timestamp}|{opaqueUUID}`，但對於 `opaqueUUID` 的生成機制和其在查詢中的具體用途不太明確。當使用 Cursor 查詢時，系統是根據 `timestamp` 來定位事件位置，還是根據 `seqId`？這會影響查詢結果的一致性，特別是在同一時間戳記有多個事件的情況下。

## 💡 改善建議

1. **明確定義事件狀態轉換流程**：詳細描述事件從接收到存儲再到查詢的完整狀態變化。
2. **補充錯誤處理機制**：特別是針對系統異常和資料損壞的處理方式。
3. **加強併發設計考量**：在 In-Memory 儲存設計中加入線程安全機制。
4. **建立資料結構索引策略**：為提高查詢效能，建議為 `companyId` 和 `seqId` 建立索引。
5. **完善測試場景設計**：包含併發情境測試，確保系統在高負載下的穩定性。

整體而言，計畫結構完整，技術選型合理，但在併發安全和部分規格解讀上需要進一步明確化，以確保實作過程中不會產生歧異。

## 回饋

1. 我先回答一部分問題，如果你看過沒問題的話把三份文件都一併更新，有疑問先找我確認，沒問題更新文件
  ```
  資料持久層應該要用介面隔離實作的相依，In-Memory 是其中一種持久層實作，作為本次 POC 的實驗，這是一個輕量的實作方案
  高併發的資料持久層設計不在 POC 範圍，我們僅須確保 Key 和 Cursor 的技術規格是否容易導致後續開發上的困難，如 關聯資料庫的 auto-increment 就會是一種難以調整的潛在的效能瓶頸點
  ```